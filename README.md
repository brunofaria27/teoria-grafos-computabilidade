<h1 > Organização de diretórios: </h1>

<strong>LEITURA GRAFOS:</strong>
- [Printar Grafo lido de um arquivo - Código C++](https://github.com/brunofaria27/teoria-grafos-computabilidade/blob/main/Leitura%20Grafos/main.cpp)

---------------
<strong>REPRESENTAÇÃO GRAFOS:</strong>
- [Matrizes de Incidência e Adjacência - Código Python](https://github.com/brunofaria27/teoria-grafos-computabilidade/blob/main/Representa%C3%A7%C3%A3o%20Grafos)
- [Lista de Adjacência de predecessores e sucessores - Código C++](https://github.com/brunofaria27/teoria-grafos-computabilidade/blob/main/Representa%C3%A7%C3%A3o%20Grafos/lista_sucessores_predecessores.cpp)
- [Lista de Adjacência de predecessores e sucessores - Código Python](https://github.com/brunofaria27/teoria-grafos-computabilidade/blob/main/Representa%C3%A7%C3%A3o%20Grafos/lista_sucessores_predecessores.py)
- [Lista de Adjacência por meio de vetores (Origem e Destino) - Código Python](https://github.com/brunofaria27/teoria-grafos-computabilidade/blob/main/Representa%C3%A7%C3%A3o%20Grafos/foward_and_reverse_star.py)

---------------
<strong>TRABALHO PRÁTICO I:</strong>

Consiste na utilização de dois algoritmos de indentificação de ponte e encontrar um caminho euleriano, respectivamente, sendo eles:
- [Método Naive - Código Python]()
- [Método de Tarjan (1974) - Código Python]()
- [Método de Fleury - Código Python]()

Além dos métodos acima, código para a geração de grafos aleatórios com uma quantidade determinada de vértices foi criado, para os testes:
- [Criação de grafos aleatórios (euleriano, semi-euleriano, não-euleriano) - Código Python]()

Analise e relatório contendo todo conhecimento abordado durante a execução do trabalho prático:
- [Analise de performace dos algoritmos de indentificação de ponte - JupyterNotebook]()
- [Relatório Final - Trabalho Prático I]()

---------------
<strong>RESUMOS TEORIA:</strong>
- [Resumos](https://github.com/brunofaria27/teoria-grafos-computabilidade/tree/main/Resumos)
